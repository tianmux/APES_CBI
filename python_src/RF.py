#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Apr  1 16:07:35 2022

@author: txin
"""
import numpy as np
import utl
import copy
from update_Vb import update_Vb_beam
from calculate_Vg import calcul_Vg
from numba import njit
c_light = utl.c_light

pi = np.pi

# This is the class of the generator current
# which includes amplitude I0
# phase phi
# and frequency wrf
class Phasor:
    A = 0
    phi = 0
    w = 0
    def __init__(self, A, phi, w):
        self.A = A
        self.phi = phi
        self.w = w
        
    def update(self, A, phi, w):
        self.A = A
        self.phi = phi
        self.w = w
# Discribe the 
# Discribe the cavity
class Cav:
    
    def __init__(self,h, fc,frf, RoQ, QL, t,nTot,feed_step,Vref, Igref,gp,gc,epsilon,delay_dt):
        self.h = h
        self.wc = fc*2*pi
        self.wrf = frf*2*pi
        self.RoQ = RoQ
        self.QL = QL
        self.R = self.RoQ*self.QL
        self.C = 1/(self.RoQ*self.wc)
        self.L = self.RoQ**2*self.C
        self.Z = self.R/(1+1j*QL*(frf/fc-fc/frf))
        self.t = t
        self.alpha = self.wc/(2*self.QL)
        self.wL = np.sqrt(1-1/(4*self.QL**2))*self.wc
        self.Vref = Vref
        self.Igref = Igref
        self.Ig = np.ndarray(len(h),dtype='complex')  # Generator current. Only keep the record of last update
        self.Igm1 = np.ndarray(len(h),dtype='complex')
        
        self.Vg = np.ndarray(len(h),dtype='complex')  # Voltage generated by the generator at the latest time point
        self.Vgm1 = np.ndarray(len(h),dtype='complex')
        
        self.Ug = np.ndarray(len(h),dtype='complex')
        self.Ugm1 = np.ndarray(len(h),dtype='complex')
        
        self.Tgn = t # time difference between t_{n} and t_{n-1}
        self.Tbn = t # time difference between t_{n-1} and t_{n-2}
        
        self.Ib = np.ndarray(len(h),dtype='complex')
        self.Ibm1 = np.ndarray(len(h),dtype='complex')
        
        self.Vb = np.ndarray(len(h),dtype='complex')  # Voltage generated by the beam at the latest time point.
        self.Vbm1 = np.ndarray(len(h),dtype='complex')
        
        self.Ub = np.ndarray(len(h),dtype='complex')
        self.Ubm1 = np.ndarray(len(h),dtype='complex')
        
        self.Vgs = np.ndarray((len(h),nTot),dtype='complex') # for macro particles
        self.Vbs = np.ndarray((len(h),nTot),dtype='complex') # for macro particles
        self.Vadds = np.ndarray((len(h),nTot),dtype='double') # for macro particles
        
        self.Vres = np.ndarray((len(h),nTot),dtype='complex') # array to keep the records of the voltage history.
        
        
        
        self.feed_step = feed_step # this is the step between each feedback update, in unit of bucket.
        self.n_feed = int(self.h[0]/self.feed_step) # number of feedback updates.
        #print("n_feed=",self.n_feed)
        self.feed_times = np.zeros(self.n_feed)
        self.feed_buckets = np.zeros(self.n_feed).astype("int")
        self.Vtot_ref = np.ndarray((self.n_feed,len(h)),dtype='complex')
        for i in range(self.n_feed):
            self.Vtot_ref[i] = copy.deepcopy(np.array([0 for i in range(len(h))]))
        self.Vg_feed = np.ndarray((len(h),self.n_feed))
        self.Vb_feed = np.ndarray((len(h),self.n_feed))
        self.gp = gp
        self.gc = gc
        self.epsilon = epsilon
        self.delay_dt = delay_dt
        print("frf = ",frf)
        for i in range(self.n_feed):
            self.feed_buckets[i] = (i+1)*self.feed_step
            self.feed_times[i] = (self.feed_buckets[i])*1.0/frf[0]+self.t+1/frf[0]/4 # initialize all update time points. Need to updated every turn. Looking at the voltage at the end of the bucket
        self.feed_buckets[-1] = h[0]-1
        self.feed_times[-1] = (self.feed_buckets[-1])*1.0/frf[0]+self.t+1/frf[0]/4
        print("self.t:",self.t)
        print("feed_times: ",((self.feed_times)-self.t)*frf[0])
        print("feed_buckets: ",self.feed_buckets)
    def PrintAll(self):
        temp = vars(self)
        for item in temp:
            print(item,":",temp[item])
        print('\n')
        
    # calculate the voltage driven by the generator current Ig, with frequency fg.
    # Ig is the phasor of generator current since last update
    # t is time between observing time and the time when the driving current was updated last time. 
    
    #def calcul_Vg(self, t):
    #    # Solution to the RLC circuit by Laplace transformation
    #    dt = t-self.Tgn
    #    #print(dt)
    #    print(self.Tgn)
    #    #print(t)
    #    #print(self.Ig)
    #    #print(self.Igm1)
    #    # To calculate the Vg at this time point 't', we need to know the information
    #    # of Ig, Vg, and Ug at last time point Tgn.

    #    A = self.alpha+1j*(self.wrf+self.wL)
    #    B = self.alpha+1j*(self.wrf-self.wL)
    #    
    #    Vg = self.Ig/self.C*\
    #        (1j*self.wrf/A/B*np.exp(1j*self.wrf*dt)\
    #        +(self.alpha+1j*self.wL)/(-2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*dt)\
    #        +(self.alpha-1j*self.wL)/(2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*dt))\
    #       +(self.Vgm1*(np.cos(self.wL*dt)-self.alpha/self.wL*np.sin(self.wL*dt))\
    #       -self.Ugm1/self.C/self.L/(1*self.wL)*np.sin(self.wL*dt))*np.exp(-self.alpha*dt)
    #    print(Vg)
    #    return Vg
    
    def calculate_VgC(self,beam,nThreads):
        calcul_Vg(self.alpha, self.wrf, self.wL, self.C, self.L, self.Tgn, \
                              self.Ig,self.Vgm1, self.Ugm1,self.Vgs,beam.ts,nThreads)
        return 1
    # Update the voltage driven by the generator current Ig, with frequency fg.
    # Ig is the phasor of generator current since last update
    # t is time between observing time and the time when the driving current was updated last time. 
    def update_Vg(self,t):
        # Solution to the RLC circuit by Laplace transformation
        dt = t-self.Tgn
        #print("dt: ",dt)
        #print("Ig: ",self.Ig)
        #print("Igm1: ",self.Igm1)
        # To calculate the Vg at this time point 't', we need to know the information 
        # of Ig, Vg, and Ug at last time point Tgn.
        A = self.alpha+1j*(self.wrf+self.wL)
        B = self.alpha+1j*(self.wrf-self.wL)
        #print(dt)
        self.Vg = np.abs(self.Ig)/self.C*np.exp(1j*np.angle(self.Ig))*\
            (1j*self.wrf/A/B*np.exp(1j*self.wrf*dt)\
            +(self.alpha+1j*self.wL)/(-2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*dt)\
            +(self.alpha-1j*self.wL)/(2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*dt))\
            +(self.Vgm1*(np.cos(self.wL*dt)-self.alpha/self.wL*np.sin(self.wL*dt))\
            -self.Ugm1/self.C/self.L/(1*self.wL)*np.sin(self.wL*dt))*np.exp(-self.alpha*dt)
        
        tmp1 = self.Ig/self.C*\
            (1j*self.wrf/A/B*np.exp(1j*self.wrf*dt)\
            +(self.alpha+1j*self.wL)/(-2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*dt)\
            +(self.alpha-1j*self.wL)/(2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*dt))
        #print("phi: ",self.wrf*dt)
        #print("dI: ",self.Ig-self.Igref)
        tmp2 = (self.Vgm1*(np.cos(self.wL*dt)-self.alpha/self.wL*np.sin(self.wL*dt))\
            -self.Ugm1/self.C/self.L/(1*self.wL)*np.sin(self.wL*dt))*np.exp(-self.alpha*dt)
        #print(self.Vgm1)
        #print(self.Ugm1)
        Vgp = np.abs(self.Ig)/self.C*np.exp(1j*np.angle(self.Ig))*\
            (-self.wrf**2/A/B*np.exp(1j*self.wrf*dt)\
            +(self.alpha+1j*self.wL)**2/(2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*dt)\
            +(self.alpha-1j*self.wL)**2/(-2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*dt))\
            +self.Vgm1*np.exp(-self.alpha*dt)*((-2*self.alpha)*np.cos(self.wL*dt)+(self.alpha**2/self.wL-self.wL)*np.sin(self.wL*dt))\
            -self.Ugm1/self.C/self.L*np.exp(-self.alpha*dt)*(-self.alpha/self.wL*np.sin(self.wL*dt)+np.cos(self.wL*dt))
        #print("Ig: ",self.Ig)
        #print("Igm1: ",self.Igm1)
        self.Ug = self.L*(self.Ig[0]*np.exp(1j*self.wrf*dt)-1/self.R*self.Vg[0]-self.C*Vgp[0])
        #self.Ug = self.L*(self.Igm1-1/self.R*self.Vg-self.C*Vgp)

        self.Tgn = t
        self.Vgm1 = self.Vg
        self.Ugm1 = self.Ug
        return tmp1, tmp2
    
    def calculate_VgC_feed(self,beam,istart, iend, nThreads):
        if iend>istart:
            #tempVgs = self.Vgs[:,int(istart*beam.nPb):int(iend*beam.nPb)]
            tempVgs = self.Vgs[:,istart:iend+1]
            calcul_Vg(self.alpha, self.wrf, self.wL, self.C, self.L, self.Tgn, \
                                  self.Ig,self.Vgm1, self.Ugm1,tempVgs,beam.ts[istart:iend+1],nThreads)
            self.Vgs[:,istart:iend+1] = copy.deepcopy(tempVgs)
            #self.update_Vg(beam.ts[istart:iend+1][-1])
            #self.Tgn = beam.ts[istart:iend+1][-1]

        return 1
    
    def calcul_Vg_no_feed(self, t):
        # Solution to the RLC circuit by Laplace transformation
        dt = t-self.Tgn
        
        A = self.alpha+1j*(self.wrf+self.wL)
        B = self.alpha+1j*(self.wrf-self.wL)
        
        Vg = np.abs(self.Ig)/self.C*np.exp(1j*np.angle(self.Ig))*\
            (1j*self.wrf/A/B*np.exp(1j*self.wrf*dt))
        
        #Vg = self.Ig*self.Z    
        
        return Vg
    
    
    # calculate the Vb with rotating phasor
    def calcul_Vb(self, t):
        dt = t-self.Tbn
        return self.Vb*np.exp((1j*self.wL-self.alpha)*dt)
    
    # Update the Vb with rotating phasor
    def update_Vb_beamC(self, beam,nThreads):
        
        update_Vb_beam(self.Vbs, beam.ts, self.Vadds, self.wL, self.alpha, self.Vb, self.Tbn,nThreads)
        #print("dphi =", dt*self.wrf)
        #print(Vadd)
        self.Vb = copy.deepcopy(self.Vbs.T[-1])
        #print(self.Vb)
        self.Tbn = beam.ts[-1]
        return 0
    
    # Update the Vb with rotating phasor
    def update_Vb_beamC_feed(self, beam, istart, iend, nThreads):
        if iend>istart:
            #tempVbs = self.Vbs[:,int(istart*beam.nPb):int(iend*beam.nPb)]
            tempVbs = self.Vbs[:,istart:iend+1]
            #print(int(istart*beam.nPb)-int(iend*beam.nPb))
            tempVadds = self.Vadds[:,istart:iend+1]
            update_Vb_beam(tempVbs, beam.ts[istart:iend+1],  tempVadds, self.wL, self.alpha, self.Vb, self.Tbn,nThreads)
            #print("dphi =", dt*self.wrf)
            #print(Vadd)
            self.Vb = copy.deepcopy(tempVbs.T[-1])
            #print(self.Vb)
            self.Tbn = beam.ts[istart:iend+1][-1]
            
        return 0

    def kick_par_beamC_feed(self, beam,dynamic_on,feed_on, nThreads):
        for ih in range(len(self.h)):
            self.Vadds[ih] = -self.RoQ[ih]*self.wL[ih]*beam.qs
        beam.ts, beam.gammas = utl.ArgSort(beam.ts,beam.gammas)
        istart = 0 # the starting index of bunch
        iend = 0 # the ending index of bunch
        
        iStartPar = 0
        iEndPar = 0
        # feedback on the total voltage for n_feed times each turn. 
        
        for i in range(self.n_feed):
            # count the number of bunches between the last feedback point and this feedback point. This assumes the particles don't leak out of the bucket.
            # iend = np.sum(beam.buckets[:self.feed_buckets[i]]) 
            
            # If some particles leak out of the bucket, the above method is not necessarily right.
            # the most rigorous way is to find the index of the particle that comes right before the feedback time point and calculate the Vb and Vg at that point. 
            # the particle time should be sorted.
            iEndPar = utl.Find_idx(beam.ts,self.feed_times[i]) # this is the index of the particle that comes right before the feedback time point. 
            # iStartPar should be the index of particle right after the last feedback time point. start with 0.
            #if i==0:
            #    print(self.feed_times[i]-beam.ts[iEndPar]-1/(self.wrf/2/pi))
            #    print((self.feed_times[i]-beam.ts[iEndPar+1])*(self.wrf/2/pi))

            #print("iEndPar = ",iEndPar)
            #if i==1:
            #    print(iStartPar)
            #    print(iEndPar)
            

            #print(self.feed_times[i])
            #print(beam.ts[iEndPar])
            #print(beam.ts[iEndPar])
            
            #print(iend)
            # Calculate the Vgs and Vbs section by section between each feedback point. 
            # self.calculate_VgC_feed(beam,istart,iend,nThreads)
            # calculate Vg do not need to update the last time point Tgn
            self.calculate_VgC_feed(beam,iStartPar,iEndPar,nThreads)
            self.Vgs=np.array(self.Vgs)
            #beam.Vgs = self.calcul_Vg_no_feed(beam.ts)
            
            # update_Vb needs to update the last time point Tbn
            self.update_Vb_beamC_feed(beam, iStartPar, iEndPar, nThreads)
            self.Vbs = np.array(self.Vbs)
            #if beam.ts[int(iend*beam.nPb)]>self.feed_times[i]:
               # print(beam.ts[int(iend*beam.nPb)], ",",self.feed_times[i])
            
            # direct feedback, zero delay. 
            # Comb filter, one turn delay.
            self.feedback(self.feed_times[i],self.gp, i, self.gc,feed_on)
             
            iStartPar = iEndPar+1
        
        beam.gammas += dynamic_on*(np.array(np.sum(np.real(self.Vgs+self.Vbs)-self.Vadds/2,axis = 0))/utl.E0e)
        return
    
    def kick_par_beamC(self,beam,dynamic_on,nThreads):
        # To get the correct kick, we need to calculate the Vg and Vb for each particle at their arriving time.
        # Vg is simple, just need to plug all time into the calcul_Vg function
        
        
        for ih in range(len(self.h)):
            self.Vadds[ih] = -self.RoQ[ih]*self.wL[ih]*beam.qs
        # This sort and zip method is a very time consuming way to sort, need to find a better approach.
        # About half of the time is spent here. 
        # now changed to argsort which saves 90% of the time.
        
        #beam.ts,beam.gammas = np.array(list(zip(*sorted(zip(beam.ts,beam.gammas)))))
        beam.ts, beam.gammas = utl.ArgSort(beam.ts,beam.gammas)
        
        #beam.Vgs = self.calcul_Vg(beam.ts)
        self.calculate_VgC(beam,nThreads)
        self.Vgs=np.array(self.Vgs)
        #beam.Vgs = self.calcul_Vg_no_feed(beam.ts)
        
        self.update_Vb_beamC(beam,nThreads)
        self.Vbs = np.array(self.Vbs)

        beam.gammas += dynamic_on*(np.array(np.sum(np.real(self.Vgs+self.Vbs)-self.Vadds/2,axis = 0))/utl.E0e)
        
        #if dynamic_on:
        #    print((ts-t0)*1e6)
        #    print(gammas)
        return
    
    def update_f():
        return
    
    def update_QL():
        return
    
    def update_Ig(self, Ig, t):
        self.Igm1 = self.Ig
        self.Ig = Ig

        self.Tn = t
        return
    
    def update_feed_times(self, T0):
        self.feed_times += T0
        #print("Feedback time points: ",self.feed_times)
    
    def feedback(self,t,gp, i, gc,feed_on):
        # at the end of the feedback bucket, look at the Vg of each mode of the cavity.
        self.update_Vg(t)
        self.Tgn = t
        # Then get the Vb at this time point. There are two different cases, 
        # 1. The Vb of last time point comes from the last macro particle, 
        # 2. The Vb of last time point comes from the last feedback probe operation. 
        # But in either cases we should update the Vb based on the time difference between the last time point 
        # and this feedback probe time point.
        #print(self.Vb)
        self.Vb = self.Vb*np.exp((1j*self.wL-self.alpha)*(t-self.Tbn))
        #print(self.Vb)

        self.Tbn = t
        Vtot = self.Vg+self.Vb
        dV = self.Vref*np.exp(1j*self.wrf*t)-Vtot
        debug = 0
        if debug ==1:
            print("time: ",t)
            print("Vref: ",self.Vref)
            print("Vg: ",self.Vg)
            print("Vb: ",self.Vb)
            print("Vtot: ",Vtot)
            print("Vref_t: ",self.Vref*np.exp(1j*self.wrf*t))
            print("dV: ",dV)
            print("dVabs :",np.abs(dV))
            print("Igref: ",self.Igref)
        #S = self.Vtot_ref[i]*(1-self.epsilon)*np.exp(1j*self.wrf*self.delay_dt)+self.epsilon*Vtot
        #self.Ig = self.Igref*np.exp(1j*self.wrf*t)+(dV/self.R*gp+1/self.R*(Vtot-S)*self.gc)*feed_on

        self.Ig = self.Igref*np.exp(1j*self.wrf*t)+(dV/self.R*gp)*feed_on

        #self.Ig = self.Igref+(dV/self.R*gp)*feed_on
        #print("phase factor: ",np.exp(1j*self.wrf*t))
        if debug == 1:
            print("Ig after: ",self.Ig)
            
        #replace the Vtot information from last turn.
        self.Vtot_ref[i] = Vtot
        
        self.update_Ig(self.Ig,t)
        #print(feed_on, i, self.Vtot_ref[i], self.Vg, self.Vb,self.Ig)
        return

    
    
    
    
    
    
    
    
    
    
    
    # Solve the Vb based on Laplace transform, can be done but slow as hell.
    def update_Vb0(self, t0, t, Q,i):
        dt = t-t0
        #Vadd = -self.RoQ*self.wc/2*q
        #self.Vb = self.Vb*np.exp((1j*self.wL-self.alpha)*(t-t0))+Vadd
        self.Vbm1 = self.Vb
        self.Ubm1 = self.Ub
        
        self.Ibm1 = self.Ib
        self.Ib = Q[i]
        
        self.Vb = -self.Ibm1/self.C*np.exp(1j*self.wrf*dt)*np.exp(-self.alpha*dt)/self.wL*(-self.alpha*np.sin(self.wL*dt)+self.wL*np.cos(self.wL*dt))\
            +(self.Vbm1*(np.cos(self.wL*dt)-self.alpha/self.wL*np.sin(self.wL*dt))\
            -self.Ubm1/self.C/self.L/(1*self.wL)*np.sin(self.wL*dt))*np.exp(-self.alpha*dt)
                
        Vbp = -self.Ibm1/self.C*np.exp(1j*self.wrf*dt)*np.exp(-self.alpha*dt)/self.wL*\
            ((-self.alpha+1j*self.wrf)*(-self.alpha*np.sin(self.wL*dt)+self.wL*np.cos(self.wL*dt))\
             +(-self.alpha*self.wL*np.cos(self.wL*dt)-self.wL**2*np.sin(self.wL*dt)))\
            +self.Vbm1*np.exp(-self.alpha*dt)*((-2*self.alpha)*np.cos(self.wL*dt)+(self.alpha**2/self.wL-self.wL)*np.sin(self.wL*dt))\
            -self.Ubm1/self.C/self.L*np.exp(-self.alpha*dt)*(-self.alpha/self.wL*np.sin(self.wL*dt)+np.cos(self.wL*dt))
        
        self.Ub = self.L*(self.Ibm1-1/self.R*self.Vb-self.C*Vbp)
        
        return
    
    # update the voltage driven by the generator current Ig, with frequency fg.
    # Ig is the phasor of generator current, 
    # tDriven is time between observing time and the time when the driving current was updated last time. 
    def calcul_Vg0(self, Ig, tDriven):
        # Solution to the RLC circuit by Laplace transformation
        
        A = self.alpha+1j*(self.wrf+self.wL)
        B = self.alpha+1j*(self.wrf-self.wL)
        # keep the record of previous interval
        self.Tnm1 = self.Tn
        self.Tn = tDriven
        
        self.Vgm1 = self.Vg
        self.Ugm1 = self.Ug
        
        
        self.Igm1 = self.Ig
        self.Ig = Ig
        #Igm1m = self.Igm2*np.exp(1j*self.wrf*self.Tnm1) # Ig at t=t_{n-1}_{-}, right before the t_{n-1}, evolved from Igm2 by simply rotating a angle wrf*Tm1
        #Vgm1m = self.Vg # Vg at t=t_{n-1}_{-}
        #print(A)
        #print(B)
        if self.Igm2.real == 0 and self.Igm2.imag == 0:
            Igm2phi = 0
        elif self.Igm2.real == 0 and self.Igm2.imag != 0:
            Igm2phi = pi/2
        else:
            Igm2phi = np.arctan(self.Igm2.imag/self.Igm2.real)
        
        if self.Igm1.real == 0 and self.Igm1.imag == 0:
            Igm1phi = 0
        elif self.Igm1.real == 0 and self.Igm1.imag != 0:
            Igm1phi = pi/2
        else:
            Igm1phi = np.arctan(self.Igm1.imag/self.Igm1.real)
        
        # Vg prime at t=t_{n-1}_{-}
        #Vgpm1m = np.abs(self.Igm2)/self.C*np.exp(1j*Igm2phi)*\
        #    (-self.wrf**2/A/B*np.exp(1j*self.wrf*self.Tnm1)\
        #    +(self.alpha+1j*self.wL)**2/(2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*self.Tnm1)\
        #    +(self.alpha-1j*self.wL)**2/(-2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*self.Tnm1))\
        #    +self.Vgm2*np.exp(-self.alpha*self.Tnm1)*((-2*self.alpha)*np.cos(self.wL*self.Tnm1)+(self.alpha**2/self.wL-self.wL)*np.sin(self.wL*self.Tnm1))\
        #    -self.Ugm2/self.C/self.L*np.exp(-self.alpha*self.Tnm1)*(-self.alpha/self.wL*np.sin(self.wL*self.Tnm1)+np.cos(self.wL*self.Tnm1))
        
        #self.Ugm1 = self.L*(Igm1m-1/self.R*Vgm1m-self.C*Vgpm1m)
        
        self.Vg = np.abs(self.Igm1)/self.C*np.exp(1j*Igm1phi)*\
            (1j*self.wrf/A/B*np.exp(1j*self.wrf*self.Tn)\
            +(self.alpha+1j*self.wL)/(-2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*self.Tn)\
            +(self.alpha-1j*self.wL)/(2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*self.Tn))\
            +(self.Vgm1*(np.cos(self.wL*self.Tn)-self.alpha/self.wL*np.sin(self.wL*self.Tn))\
            -self.Ugm1/self.C/self.L/(1*self.wL)*np.sin(self.wL*self.Tn))*np.exp(-self.alpha*self.Tn)
        Vgp = np.abs(self.Igm1)/self.C*np.exp(1j*Igm1phi)*\
            (-self.wrf**2/A/B*np.exp(1j*self.wrf*self.Tn)\
            +(self.alpha+1j*self.wL)**2/(2j*self.wL*A)*np.exp(-(1j*self.wL+self.alpha)*self.Tn)\
            +(self.alpha-1j*self.wL)**2/(-2j*self.wL*B)*np.exp((1j*self.wL-self.alpha)*self.Tn))\
            +self.Vgm1*np.exp(-self.alpha*self.Tn)*((-2*self.alpha)*np.cos(self.wL*self.Tn)+(self.alpha**2/self.wL-self.wL)*np.sin(self.wL*self.Tn))\
            -self.Ugm1/self.C/self.L*np.exp(-self.alpha*self.Tn)*(-self.alpha/self.wL*np.sin(self.wL*self.Tn)+np.cos(self.wL*self.Tn))
        
        self.Ug = self.L*(self.Igm1-1/self.R*self.Vg-self.C*Vgp)
        
        return
    
    
    def kick_par(self,bunch,dynamic_on):
        # To get the correct kick, we need to calculate the Vg and Vb for each particle at their arriving time.
        # Vg is simple, just need to plug all time into the calcul_Vg function
        ts = np.zeros(bunch.nPar)
        gammas = np.zeros(bunch.nPar)
        qPb = bunch.Q
        q = qPb/bunch.nPar
        Vadd = -self.RoQ*self.wL*q
        for i in range(bunch.nPar):
            ts[i] = bunch.Pars[i].t 
            gammas[i] = bunch.Pars[i].gamma
        #bunch.Vgs = self.calcul_Vg(ts)
        bunch.Vgs = self.calcul_Vg_no_feed(ts)
        
        ts,gammas = np.array(list(zip(*sorted(zip(ts,gammas)))))
        #if dynamic_on:
        #    print((ts-1/self.wrf*2*np.pi*(100*216240+1e9))*1e6)
        #    print(gammas)
        for i in range(bunch.nPar):
            bunch.Vbs[i] = self.update_Vb(ts[i],Vadd)
        if dynamic_on:
            gammas += (np.real(bunch.Vgs+bunch.Vbs)-Vadd/2)/utl.E0e
        for i in range(bunch.nPar):
            bunch.Pars[i].gamma = gammas[i]
        #if dynamic_on:
        #    print((ts-t0)*1e6)
        #    print(gammas)
        return
    
    def kick_par_beam(self,beam,dynamic_on):
        # To get the correct kick, we need to calculate the Vg and Vb for each particle at their arriving time.
        # Vg is simple, just need to plug all time into the calcul_Vg function
        
        Vadd = -self.RoQ*self.wL*beam.qs
        
        beam.ts,beam.gammas = np.array(list(zip(*sorted(zip(beam.ts,beam.gammas)))))
        #bunch.Vgs = self.calcul_Vg(ts)
        beam.Vgs = self.calcul_Vg_no_feed(beam.ts)
        
        #if dynamic_on:
        #    print((ts-1/self.wrf*2*np.pi*(100*216240+1e9))*1e6)
        #    print(gammas)
        # this has to be calculated in a sequencial way
        for i in range(len(beam.ts)):
            beam.Vbs[i] = self.update_Vb_beamPy(beam.ts[i],Vadd[i])
        if dynamic_on:
            beam.gammas += (np.real(beam.Vgs+beam.Vbs)-Vadd/2)/utl.E0e
        
        #if dynamic_on:
        #    print((ts-t0)*1e6)
        #    print(gammas)
        return
    
    # Update the Vb with rotating phasor
    def update_Vb(self, t,Vadd):
        dt = t-self.Tbn
        #print("dphi =", dt*self.wrf)
        #rint(Vadd)
        self.Vb = self.Vb*np.exp((1j*self.wL-self.alpha)*dt)+Vadd
        #print(self.Vb)
        self.Tbn = t
        return self.Vb
    
    # Update the Vb with rotating phasor
    def update_Vb_beamPy(self, t,Vadd):
        dt = t-self.Tbn
        #print("dphi =", dt*self.wrf)
        #print(Vadd)
        self.Vb = self.Vb*np.exp((1j*self.wL-self.alpha)*dt)+Vadd
        print(self.Vb)

        #print(self.Vb)
        self.Tbn = t
        return self.Vb
    